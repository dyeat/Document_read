## **九、應用邏輯漏洞**

>作者：Peter Yaworski
>
>譯者：飛龍
>
>協議：CC BY-NC-SA 4.0
>

應用邏輯漏洞不同於其他我們討論過的類型。雖然 HTML 注入、HTML 參數污染和 XSS 都涉及到提交一些類型的潛在惡意輸入，應用落地及漏洞實際上涉及到操縱場景和利用 Web APP 程式碼中的 Bug。
<p>

這一類型攻擊的一個值得注意的例子是 Egor Homakov 對 Github 的滲透，Github 使用 RoR 編寫。如果你不熟悉 Rails，他是一個非常流行的 Web 框架，在開發 Web 站點時，它可以處理很多繁雜的東西。

<p>

在2012 年3 月，Egor 通知了Rails 社區，通常，Rails 會接受所有提交給它的參數，並使用這些值來更新數據庫記錄（取決於開發者的實現。Rails 核心開發者的想法是，使用Rails的Web 開發者應該負責填補它們的安全間隙，並定義那個值能夠由用戶提交來更新記錄。這個行為已經在社區內人人皆知了，但是Github 上的線程展示了很少的人能夠鑑別出來它帶來的風險（[https://github.com/rails/rails/issues/5228](https://github.com/rails/rails/issues/5228)）。

當核心開發者不同意他的時候，Egor 繼續利用Github 上的認證漏洞，通過猜測和提交參數值，它包含創建日期（如果你熟悉Rails 並且知道多數數據庫記錄包含創建和更新日期列，它就不太困難）。因此，它在 Github 上傳了一個票據，年份是未來的某個日期。它也設法更新 SHH 訪問密鑰，這可以使他訪問 Github 官方的程式碼倉庫

<p>

之前提到了，這個滲透通過 Github 後端程式碼實現，它並沒有合理驗證 Egor 所做的事情，這在隨後可用於更新數據庫記錄。這裡，Egor 發現了叫做大量賦值漏洞的東西。


<p>

應用邏輯漏洞，即發現前面討論的這種類型的攻擊，更加有技巧性，因為它們依賴程式碼判定的創造性思維，並且並不僅僅是提交潛在的惡意程式碼，開發者沒有轉義它。 （不要嘗試在這裡簡化其它類型的漏洞，一些 XSS 攻擊也很複雜！）

<p>

使用 Github 的例子，Egor 知道了系統基於 Rails 以及 Rails 如何處理用戶輸入。在其他例子中，它涉及直接編程調用 API 來測試應用的行為，就像 Shopify 的管理員權限繞過那樣。或者，它涉及重複使用來自認證 API 調用的返回值，來進行後續的API 調用，本不應該允許你這麼做。


---

## **示例**

## **1. Shopify 管理員權限繞過**

```
難度：低

URL：shop.myshopify.com/admin/mobile_devices.json
報告鏈接：https://hackerone.com/reports/100938
報告日期：2015.11.22
獎金：$500
```

## **描述**

Shopify 是一個巨大並健壯的平台，它包含 Web UI 以及受支持的 API。這個例子中，API 不驗證一些權限，而 Web UI 明顯會這麼做。因此，商店的管理員，它們不被允許接受郵件提醒，可以通過操作 API 終端來繞過這個安全設置，在它們的 Apple 設備中收到提醒。

根據報告，黑客只需要：
- 使用完全訪問權限的帳號登錄 Shopify 移動應用
- 攔截`POST /admin/mobile_devices.json`的請求
- 移除該帳號的所有權限
- 移除添加的移動端提醒
- 重放`POST /admin/mobile_devices.json`的請求

這樣做之後，用戶可以接收到所有商店處的訂單的移動端提醒，因此忽略了商店配置的安全設置。


>重要結論
>
>這裡有兩個重要結論。首先，並不是所有東西都涉及程式碼注入。始終記住使用程式碼並觀察向站點傳遞了什麼信息，
>並玩玩它看看什麼會發生。這裡，所有發生>的事情是，移除 POST 參數來繞過安全檢查。
>其次，再說一遍，不是所有攻擊都基於 HTML 頁面。 API 
>終端始終是一個潛在的漏洞區域，所以確保你考慮並測試了它們。

---

## **2. 星巴克競態條件**

```
難度：中

URL：Starbucks.com
報告鏈接：http://sakurity.com/blog/2015/05/21/starbucks.html
報告日期：2015.5.21

獎金：無

```

## **描述**

如果你不熟悉競態條件，本質上它是兩個潛在的進程彼此競爭來完成任務，基於一個廚師場景，它在請求被執行期間變得無效。換句話說，這是一個場景，其中你擁有兩個進程，它們本應該是互斥的，不應該同時完成，但是因為它們幾乎同時執行，它們被允許這麼做了。
這裡是一個例子：

1. 你在手機上登錄進了你的銀行站點，並請求將 $500 從你的一個僅僅擁有 $500 的帳戶轉到另一個帳戶。

<p>

2. 這個請求花費很長時間（但是仍然處理），所以你在你的筆記本上登錄，並且再次執行了相同請求。

<p>

3. 筆記本的請求幾乎立即完成了，但是你的手機也是這樣。

<p>

4. 你刷新了銀行帳戶，並發現你的帳戶裡有 $1000。這意味著請求執行了兩次，這本不應被允許，因為你一開始只擁有 $500。

雖然這個很基礎，理念都是一樣的，一些條件存在於請求開始，在完成時，並不存在了。
<p>
所以，回到這個例子，Egor 測試了從一個星巴克的卡中轉帳，並且發現他成功觸發了競態條件。請求使用 CURL 程式幾乎同時創建。

>重要結論
>
>競態條件 是個有趣的攻擊向量，它有時存在於應用處理一些類型的餘額的地方，
>例如金額、積分，以及其他。發現這些漏洞並不總是發生在第一次嘗試的時候，
>並且可能需要執行多次重複同時的請求。這裡，Egor 在成功之前執行了 
>6 次請求。但是要記住在測試它的時候，要注意流量負荷，避免使用連續的測試請求危害到站點。

